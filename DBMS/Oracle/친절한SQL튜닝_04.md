# 4장 조인 튜닝

## 4.1 NL조인

### 4.1.1 기본 메커니즘
- 인덱스를 이용한 조인 방식
- outer에서 inner 테이블로 Nested Loop를 돌면서 결과 집합 생성, 양쪽 테이블 모두 인덱스를 이용
- outer 테이블 인덱스에서 읽은 ROWID로 outer 테이블 액세스하여 결과집합으로 보낸 후, 다음 ROWID를 찾음

### 4.1.2 NL 조인 실행계획 제어
- 실행 계획 예시
    - outer테이블은 '사원', inner테이블은 '고객'
    `
    Execution Plan
    ------------------------
    0    SELECT STATEMENT Optimizer=ALL ROWS
    1 0    NESTED LOOPS
    2 1      TABLE ACCESS (BY INDEX ROWID) OF '사원' (TABLE)
    3 2        INDEX (RANGE SCAN) OF '사원_X1' (INDEX)
    4 3      TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
    5 4        INDEX (RANGE SCAN) OF '고객_X1' (INDEX)
    `
- 자주 사용되는 힌트 설명
    - `ordered` 힌트
        - FROM 절에 기술한 순서대로 조인하라고 옵티마이저에 지시
    - `use_nl` 힌트
        - NL방식으로 조인하라고 옵티마이저에 지시
    - `leading(A, B)` 힌트
        - 명시한 순서대로 조인하라고 옵티마이저에 지시
### 4.1.3 NL 조인 수행 과정 분석
- p263 그림 4-7 참고
    - 번호 순서대로 따라가면서 이해해야 함
- 실행계획만 보고도 어떤 테이블이 outer이고, inner인지 어떤 인덱스들을 사용했는지, 어떤 조인이 발생했는 지 알 수 있어야 함
- 인덱스 구성과 쿼리문의 where 조건절만 보고도 어떤 컬럼이 인덱스 스캔 조건인지, 테이블 필터 조건인지 알 수 있어야 함
- one-plus 스캔이란
    - 인덱스 스캔 중 값이 다른 값이 나올 때까지 스캔하기 때문에, 값이 일치하는 건보다 1건 많이 스캔하게 됨

### 4.1.4 NL 조인 튜닝 포인트
- 튜닝 포인트 핵심
    - 인덱스 스캔 조건의 비효율이 있는지
    - outer 테이블의 건수가 많아 NestedLoop가 쓸데없이 많이 발생하는지
    - 인덱스의 선두 컬럼의 선택도가 낮아 수평 스캔이 너무 많아지는지
- 올바른 조인 메소드 선택
    - OLTP 시스템에서 튜닝할 때는 일차적으로 NL 조인부터 고려하는 것이 올바른 순서임
    - NL 조인으로 좋은 성능을 내기 어렵다고 판단할 경우, 소트 머지 조인 또는 해시 조인을 검토

### 4.1.5 NL 조인 특징 요약
- 특징 
    1. 랜덤 액세스 위주의 조인 방식
        - 인덱스 구성이 아무리 완벽해도, 대량 데이터 조인할 때 NL 조인이 불리한 이유
    2. 조인을 한 레코드씩 순차적으로 진행함
        - 아무리 큰 테이블을 조인하더라도 부분범위 처리가 가능한 상황이라면 매우 빠른 응답 속도를 낼 수 있음
    3. 다른 조인 방식가 비교할 때, 인덱스 구성 전략이 특히 중요함
- OLTP 시스템의 적합한 방식
    - 소량 데이터를 주로 처리하는 경우
    - 부분범위 처리가 가능한 경우

### 4.1.6 NL 조인 튜닝 실습
- 트레이스 결과 `Rows` 수를 보고 튜닝이 필요한 지 판단 가능
- INDEX SCAN의 `Rows` 건수에서 TABLE ACCESS의 `Rows` 건수와 INDEX SCAN의 건수 차이가 큰 경우 튜닝 필요
    - 불필요한 TABLE ACCESS를 많이 함
    - 이처럼 테이블을 액세스 한 후 필터링 되는 비율이 높다면 인덱스에 테이블 필터 조건 컬럼을 추가하는 것을 고려할 수 있음
- 다시 정리하는 튜닝 핵심
    - 인덱스 스캔 구간 줄이기
        - 리프 블록 수평 스캔 범위
    - 랜덤 액세스 줄이기
        - outer -> inner 루프 건수

### 4.1.7 NL 조인 확장 메커니즘
- 오라클은 NL 조인 성능을 높이기 위해 테이블 Prefetch, 배치 I/O 기능을 도입함
    - 테이블 Prefetch란
        - 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능
    - 배치 I/O란
        - 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능
- 튜닝하는 과정에 이 기능들을 표현한 실행계획
    - 본문 p270-271, 참고
- 본문 p272, NL 조인 자가 진단 보면서, 실행계획 보는 법과 인덱스 스캔 컬럼 체크하며 튜닝하는 연습해보기

## 4.2 소트 머지 조인
- 옵티마이저가 NL 조인 대신 소트 머지 조인이나 해시 조인을 선택하는 경우
    - 조인 컬럼에 인덱스가 없을 때
    - 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때

### 4.2.1 SGA vs PGA
- SGA
    - 공유 메모리 영역인 SGA에 캐시된 데이터는 여러 프로세스가 공유할 수 있음
    - 동시에 액세스 할 순 없음
        - 동시에 액세스 하려는 프로세스 간 액세스를 직렬화하기 위한 Lock 메커니즘으로서 래치(Latch)가 존재함
    - SGA의 핵심적인 구성요소는 DB 버퍼캐시임
        - 여기서 블록을 읽으려면 버퍼 Lock도 얻어야 함
- PGA
    - 각 오라클 서버 프로세스에 할당된 메모리 영역
    - 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용함
    - 할당받은 PGA 공간이 작아 데이터를 모두 저장할 수 없을 때는 Temp 테이블스페이스를 이용
    - 다른 프로세스와 공유하지 않는 독립적인 메모리 공간
        - 래치 메커니즘이 불필요 함
    - 같은 양의 데이터를 읽더라도 SGA 버퍼캐시에서 읽을 때보다 훨씬 빠름

### 4.2.2 기본 메커니즘
- 소트 머지 조인 진행 단계
    1. 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬
    2. 머지 단계: 정렬한 양쪽 집합을 서로 머지
- 소트 머지 조인 유도 힌트: `use_merge`
- Sort Area에 저장한 데이터 자체가 인덱스 역할을 하므로, 조인 컬럼에 인덱스가 없어도 사용 가능한 조인 방식

### 4.2.3 소트 머지 조인이 빠른 이유
- Sort Area에 미리 정렬해 둔 자료구조를 이용한다는 점만 다를 뿐, NL 조인과 프로세싱 자체는 같음
- 양쪽 테이블로부터 조인 대상 집합을 일괄적으로 읽어 PGA에 저장한 후 조인
    - **PGA는 프로세스만을 위한 독립적인 메모리 공간이므로 데이터를 읽을 때 래치 획득 과정이 없음**

### 4.2.4 소트 머지 조인의 주용도
- 성능적으로 해시 조인이 더 우수하지만, where 조건식이 무조건 등치(=) 조건이 아닐 때 사용할 수 없다는 단점이 있음
    - 소트 머지 조인은 등지(=) 조건이 아니여도 사용 가능
- 사용 상황
    - 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
    - 조인 조건식이 아예 없는 조인(Cross Join)

### 4.2.5 소트 머지 조인 제어하기
- `use_merge` 힌트를 기술하여 옵티마이저에 지시

### 4.2.6 소트 머지 조인 특징 요약
- 소트 머지 조인은 조인 컬럼에 대한 인덱스 유무에 영향을 받지 않음
    - NL 조인은 조인 컬럼에 대한 인덱스 유무에 크게 영향을 받음
- 스캔 위주의 액세스 방식을 사용한다는 점
    - 하지만 모든 처리가 스캔 방식으로 이루어지진 않음
- 소트 머지 조인도 양쪽 테이블로부터 조인 대상 집합을 읽을 때는 DB버퍼캐시를 경유함
    - 이때 인덱스를 이용하기도 하고, 인덱스를 탄다면 랜덤 액세스가 일어남
        - 해시 조인도 마찬가지