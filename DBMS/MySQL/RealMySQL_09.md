# 09.옵티마이저와 힌트

</br>

## 9.1 개요
- 쿼리의 실행계획을 수립하는 옵티마이저는 가장 중요한 부분
- 옵티마이저를 이해하기 위해 실행 계획부터 이해하라
- MySQL에서 실행계획 명령어는 `EXPLAIN`

### 9.1.1 쿼리 실행 절차
- 쿼리 실행 과정 3단계
    1. **SQL파싱**: 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리) > SQL 파서 모듈로 처리
    1. **최적화 및 실행 계획 수립**: SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택 > 옵티마이저가 처리
        - **쿼리변환**: 불필요한 조건 제거 및 복잡한 연산의 단순화
        - **조인 순서 결정**: 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
        - **사용 인덱스 결정**: 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
        - **집계**: 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야 하는지 결정
    1. **SQL실행**: 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴

### 9.1.2 옵티마이저의 종류
- 옵티마이저는 DB서버에서 두뇌 역할
- 최적화 규칙
    - 규칙 기반 최적화(Rule-based optimizer,RBO)
        - 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고, 내장된 우선순위에 따라 실행 계획을 수립하는 방식
        - 같은 쿼리에 대해서 거의 항상 같은 실행 방법을 생성
        - 옛날 방식이고, 요즘 거의 사용하지 않음
    - **비용 기반 최적화(Cost-based optimizer,CBO)**
        - 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출
        - 산출된 실행 방법별로 비용이 가장 낮은 처리 방식을 선택해 쿼리를 실행

</br>

## 9.2 기본 데이터 처리

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
- 풀 테이블 스캔을 선택하는 조건
    - 테이블의 레코드 건수가 너무 작은 경우
    - WHERE 또는 ON 절에 적절한 조건 컬럼이 없는 경우
    - 인덱스 레인지 스캔 범위가 너무 큰 경우
- **Read Ahead**란, 어떤 영역의 데이터가 앞으로 필요할 것이라 예측해서 요청오기 전에 미리 디스크에서 읽어 버퍼풀에 가져다 두는 것을 의미
    - 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 Foreground thread(클라이언트 스레드)가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 background thread로 넘김
    - background thread가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가 시킴
    - 이때 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둠
        - `innodb_read_ahead_ghreshold` 시스템 변수로 Read Ahead 임계값 설정
- Read Ahead는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용됨

### 9.2.2 병렬 처리
- 병렬 처리란, 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것을 의미
- 서버에 장착된 CPU의 코어 수보다 병렬 처리용 스레드 수가 많아지면 성능 떨어질 수 있음
- 병렬 스레드 수는 `innodb_parallel_read_threads` 시스템 변수를 변경하여 설정
    - ex)
    ```sql
    SET SESSION innodb_parallel_read_threads=1;
    SELECT COUNT(*) FROM salaries;
    1 row in set (0.32 sec)

    SET SESSION innodb_parallel_read_threads=4;
    SELECT COUNT(*) FROM salaries;
    1 row in set (0.18 sec)

    SET SESSION innodb_parallel_read_threads=8;
    SELECT COUNT(*) FROM salaries;
    1 row in set (0.13 sec)
    ```

### 9.2.3 ORDER BY 처리(Using filesort)
- 정렬 처리 방법
    |  | 장점 | 단점 |
    | --- | --- | --- |
    | 인덱스 이용 | `INSERT`,`UPDATE`,`DELETE` 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠름 | `INSERT`,`UPDATE`,`DELETE` 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림. </br> 인덱스 때문에 디스크 공간이 더 많이 필요. </br> 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요 |
    | Filesort 이용 | 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때 단점이 장점으로 바뀜.</br> 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름 | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 수 많아질수록 쿼리 응답 속도가 느림 |

- 사실상 인덱스는 이미 정렬되어 저장되기 때문에, 별도 정렬 연산 비용이 들지 않음
- 인덱스로 정렬 연산 생략이 불가능한 경우
    - 정렬 기준이 너무 많아서 요건별로 모두 인덱스 생성이 불가능한 경우
    - `GROUP BY`의 결과 또는 `DISTINCT` 같은 처리의 결과를 정렬해야 하는 경우
    - `UNION` 처럼 임시 테이블의 결과를 다시 정렬해야 하는 경우
    - 랜덤하게 결과 레코드를 가져와야 하는 경우
- 실행 계획의 `Extra` 컬럼에 'Using Filesort' 메시지가 표시되었으면 Filesort 이용해 정렬되었다는 의미

#### 9.2.3.1 소트 버퍼
- **소트 버퍼는 MySQL에서 (filesort)정렬을 수행하기 위해 할당받는 별도의 메모리 공간**
    - 소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납됨
- 소트 버퍼 할당 용량이 커지면 운영체제는 메모리 부족으로 인해 MySQL 프로세스를 강제 종료 (ex.10 MB이상)
    - 정렬을 위해 할당하는 소트 버퍼는 세션 메모리 영역에 해당됨
    - 최대 사용가능한 소트 버퍼의 공간은 `sort_buffer_size`라는 시스템 변수로 설정할 수 있음
    - OLTP용 MySQL 서버의 적정 소트 버퍼 크기는 56 KB ~ 1MB (저자 경험상)
    - 소트 버퍼를 크게 설정해서 빠른 성능을 얻을 수는 없지만 디스크의 읽기와 쓰기 사용량은 줄일 수 있음
- 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 큰 경우 
    - 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록해 둠
    - 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장
    - 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 함

#### 9.2.3.2 정렬 알고리즘
- **싱글 패스 정렬 방식**: 정렬 대상 크기나 건수가 작은 경우 빠른 성능을 보임
    - SELECT 대상이 되는 컬럼 전부를 담아서 정렬을 수행
    - 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트에게 넘겨줌
    - 최신 버전에서 일반적으로 사용되는 방식
- **투 패스 정렬 방식**: 정렬 대상 크기나 건수가 상당히 많은 경우 효율적
    - 정렬 대상 컬럼과 PK값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 PK로 테이블을 읽어서 SELECT할 컬럼을 가져오는 정렬 방식
    - 테이블을 두 번 읽어야 함
    - 싱글 패스 정렬 방식이 도입되기 이전부터 사용되던 방식
    - 투 패스 사용하는 경우
        - 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
        - BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함할 때

#### 9.2.3.3 정렬 처리 방법
- ORDER BY가 사용되면 반드시 3가지 처리 방법으로 정렬 처리됨
    | 정렬 처리 방법 | 실행 계획의 Extra 컬럼 내용 |
    | --- | --- |
    | 인덱스를 사용한 정렬 | 별도 표기 없음 |
    | 조인에서 드라이빙 테이블만 정렬 | "Using filesort" 메시지가 표시됨 |
    | 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | "Using temporary; Using filesort" 메시지가 표시됨 |

- 먼저 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지 검토하고, 인덱스 이용 가능하면 별도의 "Filesort" 과정 없이 인덱스를 순서대로 읽어서 결과를 반환함
- 하지만 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(Filesort)할 것임
- 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 2가지 방법 중 하나를 선택함
    - 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
    - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

##### 9.2.3.3.1 인덱스를 이용한 정렬
- 인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 컬럼이 드라이빙 테이블에 속하고, ORDER BY 순서대로 생성된 인덱스가 있어야 함
- 또한 WHERE 절에 첫 번쨰로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 함

##### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
- 이 방식으로 정렬이 처리되려면 드라이빙 테이블의 컬럼만으로 ORDER BY절을 작성해야 함

##### 9.2.3.3.3 임시 테이블을 이용한 정렬
- 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬
- 2개 이상의 테이블을 조인해서 정렬하는 경우엔 임시 테이블이 필요할 수도 있음
- 3가지 정렬 방법 중 정렬해야 할 레코드 수가 가장 많기 때문에 가장 느린 정렬 방법

##### 9.2.3.3.4 정렬 처리 방법의 성능 비교
- 스트리밍 방식
    - 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간을 보장해줌
    - limit처럼 결과 건수 줄여주는 조건들을 사용하면 시간을 상당히 줄여줄 수 있음
- 버퍼링 방식
    - ORDER BY, GROUP BY 같은 처리는 쿼리의 결과가 스트리밍 되는 것을 불가능하게 함

#### 9.2.3.4 정렬 관련 상태 변수
- 몇 건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼 간의 병합 작업(멀티 머지)은 몇 번이나 발생했는지 등 조회하는 명령어

```
mysql> FLUSH STATUS;
mysql> SHOW STATUS LIKE 'Sort%';

+--------------------------+--------+
| Variable_name            | Value  |
+--------------------------+--------+
| Sort_merge_passes        | 13     |
| Sort_range               | 0      |
| Sort_rows                | 300024 |
| Sort_scan                | 1      |
+--------------------------+--------+
```

- Sort_merge_passes는 멀티 머지처리 횟수를 의미
- Sort_range는 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 누적 횟수
- Sort_scan은 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 누적 횟수
- Sort_rows는 지금까지 정렬한 전체 레코드 건수를 의미


## 참고) 조인 테이블별 인덱스 컬럼 구성 순서
- 드라이빙 테이블 (ON절 컬럼은 인덱스 구성하지 않아도 됨)
    1. '='조건
    1. 정렬 생략 가능하다면 ORDER BY 명시 컬럼
    1. 범위 조건

- 드리븐 테이블 (1,2번 순서 바뀌어도 됨)
    1. ON절 컬럼
    1. '='조건
    1. 범위 조건