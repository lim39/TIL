# 07.데이터 암호화

</br>

## 7.1 MySQL 서버의 데이터 암호화
- 데이터베이스 서버와 디스크 사이의 데이터 읽고 쓰기 지점에서 암호화 또는 복호화를 수행
- I/O 레이어에서만 데이터의 암호화 및 복호화 과정이 실행됨
- TDE(Transparent Data Encryption)이란?
    - 데이터암호화 기능이 활성화되어 있어도 사용자 입장에선 아무런 차이를 느끼지 못하는 암호화 방식
    - 메모리나 네트워크 전송 단계가 아닌 디스크에 저장된 단계에서만 암호화됨

### 7.1.1 2단계 키 관리
- MySQL 서버의 TDE에서 암호화 키는 키링 플러그인에 의해 관리됨
- 다양한 플러그인이 제공되지만 마스터 키를 관리하는 방법만 다를 뿐 MySQL 서버 내부적으로 작동하는 방식은 모두 동일함
- 제공되는 키링 플러그인 종류
    - `keyring_file` File-Based 플러그인 (커뮤니티 에디션)
    - `keyring_encryption_file` Keyring 플러그인 (엔터프라이즈 에디션)
    - `keyring_okv` KMIP 플러그인 (엔터프라이즈 에디션)
    - `keyring_aws` Amazon Web Service Keyring 플러그인 (엔터프라이즈 에디션) 
- 데이터 암호화 키 2가지 종류
    - 마스터 키 
        - 외부의 파일을 이용하기 때문에 노출될 가능성이 있어, 주기적으로 변경해야 함
        - 변경 쿼리문
            ```sql
            ALTER INSTANCE ROTATE INNODB MASTER KEY;
            ```
    - 테이블스페이스 키(=프라이빗 키)
        - 서버 외부로 절대 노출되지 않아서, 주기적으로 변경하지 않아도 됨 
- 2단계 암호화 아키텍처
    - 마스터 키를 변경하면 MySQL 서버는 기존의 마스터 키를 이용해 각 테이블의 테이블스페이스 키를 복호화한 다음 새로운 마스터 키로 다시 암호화 함
    - 이렇게 단계 암호화 방식을 사용하는 이유는 암호화 키 변경으로 인한 과도한 시스템 부하를 피하기 위함
    - 만약 테이블스페이스 키가 변경된다면 모든 데이터를 다시 복호화했다가 다시 암호화해야 해서 쿼리 처리에도 상당한 영향을 미침


### 7.1.2 암호화의 성능
- MySQL 서버의 암호화는 TDE(Transparent Data Encryption) 방식
- 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB의 버퍼 풀에 적재됨
- 데이터 페이지가 한 번 메모리에 적재되면 암호화되지 않은 테이블과 동일한 성능을 보임
- 암호화 테이블 성능 저하 요인
    - InnoDB 버퍼 풀에 존재하지 않는 데이터 페이지를 읽어야 하는 경우에는 복호화 과정을 거쳐야 해서 쿼리가 지연될 것임
    - 암호화된 테이블이 변경되면 다시 디스크로 동기화될 때 암호화돼야 하기 때문에 디스크에 저장할 때도 추가로 시간이 더 걸림
        - 하지만 데이터 페이지 저장은 사용자의 쿼리를 처리하는 스레드가 아닌 MySQL 서버의 백그라운드 스레드가 수행하기 때문에 실제 사용자 쿼리가 지연되는 것은 아님
- AES(Advanced Encryption Standard) 암호화 알고리즘은 암호화하고자 하는 평문의 길이가 짧은 경우 암호화 키의 크기에 따라 암호화된 결과의 용량이 커질 수도 있지만, 이미 데이터 페이지는 암호화 키보다 훨씬 크기 때문에 암호화된 결과가 평문의 결과와 동일한 크기의 암호문을 반환
- TDE를 적용한다고 해도 데이터 파일의 크기는 암호화되지 않은 테이블과 동일한 크기를 가짐
    - 즉, 암호화한다고 해서 InnoDB 버퍼 풀의 효율이 달라지거나 메모리 사용 효율이 떨어지는 현상은 발생하지 않음 
- 같은 테이블에 대해 암호화와 압축이 동시에 적용되면 MySQL 서버는 압축을 먼저 실행하고 암호화를 적용함
- 압축이 암호화보다 먼저 실행되는 이유는 다음과 같음
    - 일반적으로 암호화된 결과문은 아주 랜덤한 바이트의 배열을 가지게 되는데, 이는 압축률을 상당히 떨어뜨림. 그래서 최대한 압축 효율을 높이기 위해 사용자의 데이터를 그대로 압축해서 용량을 최소화한 후 암호화를 적용함
    - 또한 암호화된 테이블의 데이터 페이지는 복호화된 상태로 InnoDB 버퍼 풀에 저장되지만, 압축된 데이터 페이지는 압축 또는 압축 해제의 모든 상태로 InnoDB 버퍼 풀에 존재할 수 있음. 그래서 암호화가 먼저 실행되고 압축이 적용된다면 MySQL 서버는 InnoDB 버퍼 풀에 존재하는 데이터 페이지에 대해서도 매번 암복호화 작업을 수행해야 됨
- 암호화된 테이블의 경우 읽기는 3~5배 정도 느리며, 쓰기의 경우에는 5~6배 정도 느린 것을 확인할 수 있으나, 밀리초 단위라 체감되지 않을 수 있음

### 7.1.3 암호화의 복제
- 소스 서버와 레플리카 서버는 서로 각자의 마스터 키와 테이블스페이스 키를 관리하기 때문에 
- 복제 멤버들의 데이터 파일은 암호화되기 전의 값이 동일하더라도 실제 암호화된 데이터가 저장된 데이터 파일의 내용은 완전히 달라짐
- 마스터 키 로테이션을 실행하면 소스 서버와 레플리카 서버가 각각 서로 다른 마스터 키를 발급받음
- 마스터 키 변경 시 백업마다 키링 파일의 백업도 함께 고려해야 함

</br>

## 7.2 `keyring_file` 플러그인 설치
- 커뮤니티 에디션에선 `keyring_file` 플러그인만 제공되고, MySQL 서버가 시작되는 단계에서 가장 빨리 초기화돼야 함
- `keyring_file` 플러그인은 테이블스페이스 키를 암호화하기 위한 마스터 키가 평문으로 디스크의 파일로 저장됨
    - `keyring_file` 플러그인이 마스터 키를 저장할 키링 파일의 경로를 `keyring_file_data` 설정에 명시하면 됨
    - `keyring_file_data` 설정의 경로는 오직 하나의 MySQL 서버만 참조해야 함
    - 하나의 리눅스 서버에 MySQL 서버가 2개 이상 실행 중이라면 각 MySQL 서버가 서로 다른 키링 파일을 사용하도록 설정해야 함
- `keyring_file` 플러그인이 초기화되면 MySQL 서버는 플러그인의 초기화와 동시에 `keyring_file_data` 시스템 변수의 경로에 빈 파일을 생성함

</br>


## 7.3 테이블 암호화
- 키링 플러그인은 마스터 키를 생성하고 관리하는 부분까지만 담당하기 때문에 어떤 키링 플러그인을 사용하든 관계없이 암호화된 테이블을 생성하고 활용하는 방법은 모두 동일함 

### 7.3.1 테이블 생성
- TDE를 이용하는 테이블 생성 쿼리문이고, 일반적인 테이블 생성 구문 마지막에 "ENCRYPTION='Y'" 옵션만 추가로 넣으면 됨
    ```sql
    CREATE TABLE tab_encrypted(
        id INT,
        data VARCHAR(100),
        PRIMARY KEY(id)
    ) ENCRYPTION='Y';

    INSERT INTO tab_encrypted VALUES (1,'test_data');

    SELECT * FROM tab_encrypted;
    +----+-----------+
    | id | data      |
    +----+-----------+
    |  1 | test_data |
    +----+-----------+
    ```
- 암호화 테이블에 데이터가 디스크에 기록될 때는 데이터가 자동으로 암호화되어 저장되고, 다시 디스크에서 메모리로 읽어올 때 복호화됨
- 암호화 테이블 조회 쿼리문
    ```sql
    SELECT table_schema, table_name, create_options
    FROM information_schema.tables
    WHERE table_name= 'tab_encrypted';
    +--------------+-----------------+-----------------+
    | table_schema |    table_name   |  create_options |
    +--------------+-----------------+-----------------+
    | test         |  tab_encrypted  | encryption='Y'  |
    +--------------+-----------------+-----------------+
    ```
- 모든 테이블에 암호화 적용하려면 `default_table_encryption` 시스템 변수를 `ON`으로 설정 > ENCRYPTION 옵션을 별도로 설정하지 않아도 됨

### 7.3.2 응용 프로그램 암호화의 비교
- 응용 프로그램에서 직접 암호화해서 MySQL 서버에 저장하는 경우, 저장되는 컬럼의 값이 이미 암호화된 것인지 여부를 인지하지 못함
- 암호화된 컬럼은 인덱스를 생성하더라도 인덱스의 기능을 100% 활용할 수 없음

### 7.3.3 테이블스페이스 이동
- 원본 MySQL 서버와 목적지 MySQL 서버의 마스터 키가 달라서 임시로 사용할 마스터 키를 발급해서 테이블스페이스 이동 진행
- 자세한건 p206 참고

</br>


## 7.4 언두 로그 및 리두 로그 암호화
- MySQL 서버는 리두 로그나 언두 로그를 평문으로 저장하다가 암호화가 활성화되면 그때부터 생성되는 리두,언두 로그만 암호화해서 저장함
- 반대로 리두,언두 로그가 암호화되는 상태에서 암호화를 비활성화하면 그때부터 저장되는 로그만 평문으로 저장함
    - 그래서 리두,언두 로그 내 데이터가 지워지지 않는 동안은 암호화키가 유지되어야 함
- InnoDB 리두 로그가 암호화됐는지 확인하는 쿼리문
    ```sql
    SHOW GLOBAL VARIABLES LIKE 'innodb_redo_log_encrypt';
    ```

</br>


## 7.5 바이너리 로그 암호화
- 테이블 암호화가 적용돼도 바이너리 로그와 릴레이 로그 파일 또한 리우,언두 처럼 평문으로 저장함
- 리두,언두에 비해 상당히 긴 시간동안 보관하는 바이너리 로그는 보안에 민감할 수 있음
- 바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당함

### 7.5.1 바이너리 로그 암호화 키 관리
- 

### 7.5.2 바이너리 로그 암호화 키 변경

### 7.5.3 mysqlbinlog 도구 활용